<?php

namespace SqlProcessing\Steps\SqlFile;

use SqlProcessing\Exceptions\SqlFileLoadingException;
use SqlProcessing\Exceptions\SqlFileParseException;
use SqlProcessing\Exceptions\SqlRunnerException;
use SqlProcessing\Log\Loggable;
use SqlProcessing\Log\Logger;
use SqlProcessing\Runners\SqlRunner;
use SqlProcessing\Steps\SqlStep;
use SqlProcessing\Utils\LogUtils;

/**
 * # Шаг, запускающий SQL файлы
 *
 * Может запускать несколько файлов, если указать {@see setFile() имя файла} как массив,
 * тогда они обработаются и запустятся в порядке их следования в массиве.
 *
 * Также можно указать {@see setDir() папку с SQL файлами}, в которой лежат все указанные файлы.
 *
 * Ниже краткая инструкция к написанию файлов, которые может запускать этот шаг.
 *
 * -----
 * # Инструкция
 * -----
 * ## Аннотации
 * -----
 * При запуске SQL файла используется специальный препроцессинг тегов (аннотаций).
 * Аннотация - однострочный комментарий (начинается с `--`), в начале которого
 * указывается знак `@` а затем ключевое слово. Ключевое слово __регистронезависимое__.
 * После ключевого слова идёт текст или содержимое аннотации.
 *
 * Пример:
 *
 * **!!! Здесь и ниже в примерах между &#64; и ключевым словом знак `'`, это из-за
 * ограничения phpDoc, в реальных условиях пишется слитно**
 * ```
 *     -- @'query Это аннотация Query. Сейчас запустится запрос.
 *     CREATE TEMP TABLE ...
 * ```
 * Для правильного распознавания аннотации вся строка должна начинаться с такого комментария.
 * Полный список аннотаций ниже
 *
 * -----
 * ### Тег _&#64;query_. Аннотация для выделения запроса.
 * -----
 * Следует писать непосредственно перед запросом.
 * Текст аннотации запишется в логи до выполнения запроса как __INFO__.
 *
 * -----
 * ### Тег _&#64;params_. Аннотация для регистрации SQL параметров.
 * -----
 * Указывает, какие из {@see setParams() переданных в SqlFileStep SQL параметров} используются
 * в следующем SQL запросе. Пример корректного текста этой аннотации:
 * ```
 *      -- @'params foo, bar, baz
 * ```
 * Такая аннотация скажет препроцессору "В следующем SQL запросе будут использоваться
 * параметры `:foo`, `:bar` и `:baz`".
 *
 * Если будет указан параметр, который не был передан в SqlFileStep, то
 * выбрасится исключение {@see SqlFileParseException}
 *
 * -----
 * ### Тег _&#64;log_. Аннотация лога.
 * -----
 * Текст аннотации запишется как __INFO__. Сообщение в логи строится по тем
 * же правилам, что и сообщения для {@see Logger} - используется {@see LogUtils::prepareMessage()}.
 *
 * Если в аннотации имеется такое лог-сообщение с параметрами, то значения для
 * параметров возьмутся из следующего SQL-запроса, а лог-сообщение
 * будет записано только после его выполнения.
 *
 * При этом будет использоваться
 * {@see SqlRunner::fetchRowBoth()}, а значит можно использовать плейсхолдеры как
 * в формате `{0}, {1}`, так и в формате `{param1}, {param2}`, где имена
 * параметров - заголовки полей в результате запроса.
 * Можно даже смешивать, но нежелательно.
 *
 * Если в аннотации задействованы параметры,
 * следующий SQL __обязательно__ будет запущен как
 * возвращающий данные (SELECT). Для логирования результатов таких запросов,
 * как INSERT/DELETE/UPDATE см. ниже.
 *
 * <small>
 *   \* Примечательно, что технически _&#64;log_ без параметров - то же самое,
 *   что и _&#64;query_. Более того, в данной реализации эти теги обрабатываются
 *   одинаково, и можно даже в _&#64;query_ использовать лог-параметры. Но не надо
 *   этого делать. Тег _&#64;query_ нужен исключительно для выделения запросов и лог-сообщений
 *   без параметров
 * </small>
 *
 * -----
 * ### Тег _&#64;log-affected_. Аннотация лога затронутых строк.
 * -----
 * Записывает в логи количество затронутых строк. Само сообщение:
 * ```
 *     -- @'log-affected Запрос затронул {0} строк
 * ```
 * где `{0}` -- это количество затронутых строк. Данная аннотация применима к запросам на
 * изменение данных - INSERT/DELETE/UPDATE. На SELECT'е выйдет ошибка.
 *
 * Если есть текст аннотации, то работает как _&#64;log_, но всегда пишет сообщение
 * после следующего за ним SQL-запроса.
 *
 * Также текст сообщения мягко требует наличие одного индексированного параметра.
 * Пример правильного лог сообщения для такой аннотации:
 * ```
 *     -- @'log-affected В мою любимую табличку вставилось {0} новых записей.
 *     INSERT INTO ...
 * ```
 * Если плейсхолдера в таком сообщении не будет - в логах это отразится как __WARN__.
 *
 * -----
 * ### Тег _&#64;process_. Аннотация для красоты и для проверки, что всё работает.
 * -----
 * Пишет в логи __INFO__ с текстом аннотации в формате:
 * ```
 *     Процесс <**текст аннотации**>
 * ```
 * Семантически эта аннотация является заголовком файла, но
 * в целом она не нужна и бесполезна.
 *
 * -----
 * ### Метатег _&#64;_. Продолжение предыдущей аннотации.
 * -----
 * Позволяет продолжить текст аннотации на следующей строке.
 * ```
 *     -- @'query Очень длинное описание следующего запроса.
 *     -- @       Очень много очень важной информации,
 *     -- @       которая не влезает в одну строку
 * ```
 *
 * Делать отступы между _&#64;_ и продолжением текста не обязательно, но
 * это же так красиво!
 *
 * Так можно продлить абсолютно любую аннотацию, все переносы строк и пробелы
 * заменятся одним пробелом, потому знаки препинания всё же надо ставить.
 *
 * Можно даже писать текст аннотации на следующей строке после основного тега.
 * ```
 *     -- @'query
 *     -- @ А сообщение про запрос вот тут, пониже
 * ```
 *
 * Параметры тоже можно расположить в столбик, но обязательно нужны запятые
 * ```
 *     -- @'params
 *     -- @ foo,
 *     -- @ bar,
 *     -- @ parameterNumberOne
 * ```
 *
 * -----
 * ## SQL скрипты
 * -----
 * Аннотации в SQL файлах в целом необязательны. Если в SQL файле находится ровно один SQL
 * скрипт, то SqlFileStep просто выполнит этот скрипт и всё.
 *
 * НО если в SQL файле находится больше одного запроса, каждый из них должен отделяться от
 * следующего хотя бы одной аннотацией.
 * ```
 *     --- НАЧАЛО ФАЙЛА .sql ---
 *     INSERT INTO ...
 *     -- @'query
 *     INSERT INTO ...
 *     ------ КОНЕЦ ФАЙЛА ------
 * ```
 * Знак `;` при этом не обязателен, но чтобы файл оставался
 * валидным SQL файлом всё же его лучше оставлять
 *
 * Некоторые аннотации, например _&#64;log_ без плейсхолдеров или _&#64;process_,
 * не требуют SQL запроса, а обрабатываются на месте.
 *
 * Другие же, такие как _&#64;log-affected_, _&#64;params_ или _&#64;log_ с плейсхолдерами,
 * запоминаются и применяются к первому следующему за ними SQL-запросу. При этом аннотации
 * не обязательно быть непосредственно перед запросом:
 * ```
 *     -- @'params param1, param_31
 *
 *     -- пустые строки, комментарии
 *
 *     SELECT :param1::int, :param_31::text;
 * ```
 *
 * Но всё же нежелательно размещать что-то между связанными с запросом
 * аннотациями и самим запросом.
 *
 * Также можно применять несколько аннотаций к запросу:
 * ```
 *     -- @'query        Я аннотация независимая, пишу это до запроса
 *     -- @'log-affected А я уже буду делать своё дело после
 *     -- @              запроса. Он, кстати, удалил {0} строк
 *     -- @'params       a1, b2, veryGoodParam
 *     DELETE ...
 * ```
 *
 * -----
 * ### Комментарии
 * -----
 * Препроцессор полностью игнорирует строки с однострочными комментариями,
 * которые не являются аннотацией. При этом пропускаются даже те строки, которые посреди
 * SQL запроса, без ущерба самому запросу.
 * ```
 *     SELECT a,
 *       b,
 *     -- А препроцессор меня вообще не видит
 *       c
 *     FROM abc_table;
 * ```
 *
 * Также препроцессор смело пропускает пустые строки или строки в которых только
 * пробелы/табы (возможно это помешает делать строки с помощью $$, но таковы жертвы
 * простоте препроцессора).
 *
 * Многострочные комментарии __это плохо__.
 * Препроцессор не игнорирует их и может посчитать такой комментарий
 * частью SQL запроса или даже отдельным (!) SQL запросом.
 * ```
 *     -- @'log Где-то внизу запрос
 *
 *     /* А я комментарий, но препроцессор подумает что я запрос
 *        и потом меня попытаются запустить и всё поломается!
 *        Лучше не используй меня. Меня даже нормально
 *        в этот докблок не смогли вставить,
 *        потому я закроюсь вот так ----> * /
 *
 *     -- @'query А вот и запрос!
 *     -- А я правильный комментарий! Всё круто!
 *     INSERT INTO ...
 * ```
 *
 * -----
 * ## Рекомендации и пожелания
 * -----
 *
 * Ниже пару рекомендаций к тому, как лучше всего структурировать SQL файлы для
 * запуска с помощью этого инструмента.
 *
 * ### 1. Используй временные таблицы.
 *
 * Если надо что-то куда-то сначала сохранить, а потом из этого выбрать
 * несколько раз, по полученной выборке выполнить INSERT, а потом ещё
 * и UPDATE и DELETE'нуть в конце записи, которые
 * не учавствовали в этом круговороте данных, то лучше не писать всё в одном запросе.
 *
 * Не надо использовать WITH для этого. Он хоть и экономит время, для данной категории SQL
 * запросов эта экономия мизерна, SQL процессы всё равно не запускаются в рантайме.
 * Используй временные таблицы. Вот хороший пример:
 *
 * ```
 *     -- @'query
 *     CREATE TEMP TABLE data_to_update_and_insert
 *     AS SELECT ...
 *     ;
 *
 *     -- @'query
 *     INSERT INTO ...
 *     SELECT * FROM data_to_update_and_insert WHERE ...
 *     ;
 *
 *     -- @'query
 *     UPDATE ...
 *     FROM data_to_update_and_insert
 *     WHERE ...
 *     ;
 *
 *     -- @'query
 *     DROP TABLE data_to_update_and_insert
 *     ;
 * ```
 *
 * ### 2. Пиши комментарии
 *
 * Не стоит и говорить, что сокращения и название таблиц непонятными
 * именами в сложных запросах - __зло__.
 *
 * Но не стоит также и забывать о комментариях.
 *
 * Улучшим хороший пример:
 * ```
 *     -- Создание временной таблицы с данными из
 *     -- нескольких очень важных источников.
 *     -- Данные берутся по условию ...
 *     -- бла бла бла, много понятной информации
 *     -- @'query
 *     CREATE TEMP TABLE data_to_update_and_insert
 *     AS SELECT ... ;
 *
 *     -- Вставка в таблицу данных из времянки выше, таких,
 *     -- для которых не выполняется условие ...
 *     -- @'query
 *     INSERT INTO ...
 *     SELECT * FROM data_to_update_and_insert WHERE ... ;
 *
 *     -- Обновление записей в таблице ...
 *     -- данными из времянки выше,
 *     -- Интересная подробность, про которую
 *     -- вы возможно не знали - ...
 *     -- @'query
 *     UPDATE ...
 *     FROM data_to_update_and_insert
 *     WHERE ... ;
 * ```
 *
 * ### 3. Аннотируй
 *
 * Не стоит делать пустые файлы с одними только _&#64;query_. Подбирай нужную аннотацию,
 * пиши наиболее важную информацию, ведь это всё отразится в логах,
 * а значит можно будет быстро проверить,
 * какой именно запрос занял полчаса, и на каком из них всё сломалось.
 *
 * Пример становится почти идеальным:
 * ```
 *     -- Создание временной таблицы с данными из
 *     -- нескольких очень важных источников.
 *     -- Данные берутся по условию ...
 *     -- бла бла бла, много понятной информации
 *     -- @'query Создаётся времянка такая-то такая-то
 *     CREATE TEMP TABLE data_to_update_and_insert
 *     AS SELECT ... ;
 *
 *     -- Вставка в таблицу данных из времянки выше, таких,
 *     -- для которых не выполняется условие ...
 *     -- @'query Выполняется инсерт в таблицу ...
 *     -- @'log-affected
 *     INSERT INTO ...
 *     SELECT * FROM data_to_update_and_insert WHERE ... ;
 *
 *     -- Обновление записей в таблице ...
 *     -- данными из времянки выше,
 *     -- Интересная подробность, про которую
 *     -- вы возможно не знали - ...
 *     -- @'query Обновляются записи в таблице ...
 *     -- @'log-affected [НАЙДИ-МЕНЯ-В-ЛОГАХ] Обновилось {0} записей
 *     UPDATE ...
 *     FROM data_to_update_and_insert
 *     WHERE ... ;
 * ```
 *
 * ### Если ты используешь Git...
 * Не пиши всё в одну строку! Пожалуйста!
 *
 * Даже `;` лучше перенеси на следующую,
 * чтобы добавление нового условия в `WHERE` или нового поля в `ORDER BY` в конце запроса
 * помечалось только позитивным зелёненьким `+`.
 *
 * Вот так:
 * ```
 *    WHERE ...
 *      AND ...
 *    ;
 * ```
 *
 * ### И на последок
 * Больше всего времени я, автор этого всего, потратил на написание инструкции, конечно же,
 * но придумываение и написание такого вот маленького интерпретатора тоже
 * заняло пару минут.
 *
 * Всё это сделано для того, чтобы те, кто им пользовались, писали красивые, легко читаемые
 * и быстро отлаживаемые SQL файлы. Мне будет очень приятно знать, что даже такой примитивный
 * инструмент помог сделать чей-то проект, а желательно тот проект, для которого это всё
 * задумывалось, красивее и удобнее в поддержке.
 *
 * @author Roman Mitasov <metas_roman@mail.ru>
 */
class SqlFileStep implements SqlStep, Loggable
{
    /** @var string|array */
    private $_file;

    private $_dir;

    /** @var SqlRunner */
    private $_sqlRunner;

    private $_params;

    /** @var Logger */
    private $log;

    public function run()
    {
        if ($this->_sqlRunner === null) {
            throw new SqlRunnerException("Sql runner is not set in SqlFileStep");
        }

        if ($this->_file === null) {
            throw new SqlFileLoadingException("File is null");
        }

        foreach ((array) $this->_file as $fileName) {
            $this->processFile($fileName, $this->_dir);
        }
    }

    /**
     * Обработка SQL файла.
     *
     * В данном методе происходит упрощённый синтаксический анализ
     * с помощью конечного автомата
     *
     * Подробнее в комментариях к коду
     *
     * @param $fileName
     * @param $dir
     * @return void
     *
     * @throws SqlFileLoadingException Если файла нет
     * @throws SqlFileParseException Ошибки в ходе анализа
     * @author Roman Mitasov <metas_roman@mail.ru>
     */
    private function processFile($fileName, $dir)
    {
        $path = $dir . DIRECTORY_SEPARATOR . $fileName;

        if (!file_exists($path)) {
            throw new SqlFileLoadingException("Файл $path не найден");
        }

        $this->log->info("Запуск файла $path");

        $file = fopen($path, 'r');

        // ридер это лексичесий анализатор, построчно
        // читает файл и возвращает токены
        $reader = new SqlFileReader($file);

        // флажки и буферные переменные
        $requested_param_names      = null;
        $log_params_is_requested    = false;
        $rows_affected_is_requested = false;
        $log_message                = null;

        while (true) {
            // получение очередного токена
            $token = $reader->nextToken();

            // а вот и автомат
            switch ($token->getType()) {
                // если токен тег
                case Token::TAG:
                    // и является тегом @process
                    if ($token->is(Token::TAG_PROCESS)) {
                        // вывести в лог заголовочек. Этот тег тестовый, оставил для красоты
                        $this->log->info(
                            "[$fileName:{$token->getLine()}] "
                            . "Процесс <{$token->getContent()}>"
                        );
                        continue 2;
                    }
                    // и является тегом @log или @query
                    if ($token->is(Token::TAG_LOG) || $token->is(Token::TAG_QUERY)) {
                        // без содержимого - ничего не делать
                        if (!$token->getContent()) {
                            continue 2;
                        }

                        // иначе работаем с сообщением в логи
                        $log_message = $token->getContent();

                        // если сообщение не требует указания параметров - сразу выводить его
                        // иначе сохранятся параметры и ждём выполнения SQL запроса
                        if (!$log_params_is_requested = LogUtils::paramsRequired($token->getContent())) {
                            if ($rows_affected_is_requested) {
                                throw new SqlFileParseException(
                                    "Тег @log с параметрами не может быть использован "
                                    . "одновременно с тегом @log-affected",
                                    $token->getLine()
                                );
                            }
                            $this->log->info("[$fileName:{$token->getLine()}] $log_message");
                            $log_message = null;
                        }
                        continue 2;
                    }
                    if ($token->is(Token::TAG_LOG_AFFECTED)) {
                        if ($log_params_is_requested) {
                            throw new SqlFileParseException(
                                "Тег @log-affected не может быть использован "
                                . "одновременно с тегом @log с параметрами",
                                $token->getLine()
                            );
                        }

                        if ($log_message = $token->getContent()) {
                            if (!LogUtils::paramsRequired($token->getContent())) {
                                $this->log->warn(
                                    "[$fileName:{$token->getLine()}] "
                                    . "Использован тег @log-affected с "
                                    . "сообщением, но без плейсхолдера для вставки значения "
                                    . "затронутых строк"
                                );
                            }
                        }

                        $rows_affected_is_requested = true;
                        continue 2;
                    }
                    // и является тегом @params
                    if ($token->is(Token::TAG_PARAMS)) {
                        // не ожидается что он будет пустым, но это не жёсткая ошибка
                        if (!$token->getContent()) {
                            $this->log->warn("[$fileName:{$token->getLine()}] Пустой тег @params");
                            continue 2;
                        }

                        // получаем имена параметров, которые потребуются для SQL запроса
                        $requested_param_names = array_filter(preg_split(
                            '~\s*,\s*~',
                            $token->getContent()
                        ));
                        continue 2;
                    }
                    break;
                // если токен скрипт
                case Token::SCRIPT:
                    $params = array();
                    // и скрипту нужны параметры,
                    // то подготавливаем массив с параметрами
                    if ($requested_param_names !== null) {
                        foreach ($requested_param_names as $name) {
                            if (isset($this->_params[$name])) {
                                $params[$name] = $this->_params[$name];
                                continue;
                            }

                            $name_with_col = ':' . $name;

                            if (isset($this->_params[$name_with_col])) {
                                $params[$name] = $this->_params[$name_with_col];
                                continue;
                            }

                            throw new SqlFileParseException(
                                "Указан неверный параметр: $name",
                                $token->getLine()
                            );
                        }

                        $requested_param_names = null;
                    }

                    // если есть лог сообщение с параметрами,
                    // тогда скрипт что-то должен вернуть
                    // иначе просто запустить скрипт
                    if ($log_params_is_requested) {
                        if ($log_message === null) {
                            throw new SqlFileParseException(
                                "Лог сообщение не сохранилось, а параметры есть",
                                $token->getLine()
                            );
                        }

                        // fetch both чтобы можно было использовать
                        // как именованные параметры - {параметр},
                        // так и индексированные с 0 - {0}, {1}...
                        $row = $this->_sqlRunner->fetchRowBoth($token->getContent(), $params);

                        $this->log->info("[$fileName:{$token->getLine()}] $log_message", $row);

                        $log_params_is_requested = false;
                        $log_message             = null;
                    } else {
                        $cnt = $this->_sqlRunner->execute($token->getContent(), $params);
                        if ($rows_affected_is_requested) {
                            if ($log_message) {
                                $this->log->info(
                                    "[$fileName:{$token->getLine()}] $log_message",
                                    array($cnt)
                                );
                                $log_message = null;
                            } else {
                                $this->log->info(
                                    "[$fileName:{$token->getLine()}] Запрос затронул $cnt строк"
                                );
                            }

                            $rows_affected_is_requested = false;
                        }
                    }
                    break;
                // если токен - конец файла - выключаем автомат
                case Token::END:
                    break 2;
            }
        }

        $this->log->info("Процесс в файле $fileName завершился");
        fclose($file);
    }

    public function setFile($file)
    {
        $this->_file = $file;
    }

    public function setSqlRunner(SqlRunner $runner)
    {
        $this->_sqlRunner = $runner;
    }

    public function setLogger(Logger $logger)
    {
        $this->log = $logger;
    }

    /**
     * @param mixed $params
     */
    public function setParams($params)
    {
        $this->_params = $params;
    }

    /**
     * @return mixed
     */
    public function getDir()
    {
        return $this->_dir;
    }

    /**
     * @param mixed $dir
     */
    public function setDir($dir)
    {
        $this->_dir = $dir;
    }

    public function getLogger()
    {
        return $this->log;
    }

    public function getSqlRunner()
    {
        return $this->_sqlRunner;
    }
}