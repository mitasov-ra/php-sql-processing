# SqlProcessing

Нужен для описания процесса (изначально SQL, но в принципе любого), как последовательность шагов.

Процесс описывается интерфейсом `SqlProcess`, который оперирует сущностями интерфейса `Step`.
В общем случае, `SqlProcess` сначала наполняется экземплярами `Step`, а потом
запускает их по порядку.

Уже реализованы шаги:
 - `PhpStep` - шаг запускает PHP-callable
 - `SqlStep` - интерфейс шагов, работающих с SQL
    - `ExecuteSqlStatementStep` - шаг выполняет SQL запрос с параметрами
    - `SqlFileStep` - шаг, запускающий SQL файл или несколько файлов в
       указанной папке с параметрами
       
Также для удобного создания этих шагов имеются фабричные методы в классе `Utils\Steps`.

Для шагов интерфейса `SqlStep` нужен экземпляр `SqlRunner`, реализован `PDOSqlRunner`.
Если нужно использовать фреймворк или другую реализацию SQL (например Doctrine),
достаточно реализовать интерфейс.

Также некоторые классы (реализующие интерфейс `Loggable`) используют `Logger`,
интерфейс для логирования.

Реализации для `Logger` нет, по умолчанию используется пустышка `VoidLogger`, но
имеется `LogUtils`, для написания своей реализации.

### Установка

Просто скопировать исходный код себе в проект и настроить автолоадинг.

Пока не внедрены Composer или другие способы установки.

### Совместимость и зависимости

Совместимо с PHP 5.3 и выше. Внешних зависимостей нет.

### Пример

```php
$process = new CommonSqlProcess();
$process->setDefaultLogger($custom_log);
$process->setDefaultSqlFilesDir('/path/to/my/sql/files');
$process->setDefaultSqlRunner(new PDOSqlRunner());

$process->addSteps(array(
    Steps::fromPhpCallable(function () use ($custom_log) {
        $custom_log->info('Запущен {php} шаг', array('php' => 'PHP 5.3'));
    }),
    Steps::sqlFileStep(
        array(
            'setup-environment.sql',
            'perform-modification.sql',
            'clear-environment.sql',
        ),
        array(
            'param1' => $param1,
            'param2' => $param2,
        ),
    ),
    Steps::fromPhpCallable(function () use ($custom_log) {
        $custom_log->info('Процесс закончился');
    }),
));

```

Главная цель создания всей этой структуры - запуск sql файлов в нужном порядке с
удобным логированием каждого этапа.

Для этого используется `SqlFileStep`.
Ниже инструкция для написания файлов, запускаемых `SqlFileStep`.

# Инструкция

## Аннотации

При запуске SQL файла используется специальный препроцессинг тегов (аннотаций).
Аннотация - однострочный комментарий (начинается с `--`), в начале которого
указывается знак `@` а затем ключевое слово. Ключевое слово __регистронезависимое__.
После ключевого слова идёт текст или содержимое аннотации.
Пример:
**!!! Здесь и ниже в примерах между &#64; и ключевым словом знак `'`, это из-за
ограничения phpDoc, в реальных условиях пишется слитно**
```sql
    -- @query Это аннотация Query. Сейчас запустится запрос.
    CREATE TEMP TABLE ...
```
Для правильного распознавания аннотации вся строка должна начинаться с такого комментария.
Полный список аннотаций ниже

### Тег _&#64;query_. Аннотация для выделения запроса.

Следует писать непосредственно перед запросом.
Текст аннотации запишется в логи до выполнения запроса как __INFO__.

### Тег _&#64;params_. Аннотация для регистрации SQL параметров.

Указывает, какие из переданных в `SqlFileStep` SQL параметров используются
в следующем SQL запросе. Пример корректного текста этой аннотации:
```sql
     -- @params foo, bar, baz
```
Такая аннотация скажет препроцессору "В следующем SQL запросе будут использоваться
параметры `:foo`, `:bar` и `:baz`".
Если будет указан параметр, который не был передан в `SqlFileStep`, то
выбросится исключение `SqlFileParseException`

### Тег _&#64;log_. Аннотация лога.

Текст аннотации запишется как __INFO__. Сообщение в логи строится по тем
же правилам, что и сообщения для `Logger` - используется `LogUtils::prepareMessage()`.
Если в аннотации имеется такое лог-сообщение с параметрами, то значения для
параметров возьмутся из следующего SQL-запроса, а лог-сообщение
будет записано только после его выполнения.
При этом будет использоваться `SqlRunner::fetchRowBoth()`, а значит можно использовать
плейсхолдеры как в формате `{0}, {1}`, так и в формате `{param1}, {param2}`, где имена
параметров - заголовки полей в результате запроса.
Можно даже смешивать, но нежелательно.
Если в аннотации задействованы параметры,
следующий SQL __обязательно__ будет запущен как
возвращающий данные (SELECT). Для логирования результатов таких запросов,
как INSERT/DELETE/UPDATE см. ниже.

<small>
  * Примечательно, что технически &#64;log без параметров - то же самое,
  что и &#64;query. Более того, в данной реализации эти теги обрабатываются
  одинаково, и можно даже в &#64;query использовать лог-параметры. Но не надо
  этого делать. Тег &#64;query нужен исключительно для выделения запросов и лог-сообщений
  без параметров
</small>

### Тег _&#64;log-affected_. Аннотация лога затронутых строк.

Записывает в логи количество затронутых строк. Само сообщение:
```sql
    -- @log-affected Запрос затронул {0} строк
```
где `{0}` -- это количество затронутых строк. Данная аннотация применима к запросам на
изменение данных - INSERT/DELETE/UPDATE. На SELECT'е выйдет ошибка.
Если есть текст аннотации, то работает как _&#64;log_, но всегда пишет сообщение
после следующего за ним SQL-запроса.
Также текст сообщения мягко требует наличие одного индексированного параметра.
Пример правильного лог сообщения для такой аннотации:
```sql
    -- @log-affected В мою любимую табличку вставилось {0} новых записей.
    INSERT INTO ...
```
Если плейсхолдера в таком сообщении не будет - в логах это отразится как __WARN__.

### Тег _&#64;process_. Аннотация для красоты и для проверки, что всё работает.

Пишет в логи __INFO__ с текстом аннотации в формате:
```
    Процесс <**текст аннотации**>
```
Семантически эта аннотация является заголовком файла, но
в целом она не нужна и бесполезна.

### Мета-тег _&#64;_. Продолжение предыдущей аннотации.

Позволяет продолжить текст аннотации на следующей строке.
```sql
    -- @query Очень длинное описание следующего запроса.
    -- @      Очень много очень важной информации,
    -- @      которая не влезает в одну строку
```
Делать отступы между _&#64;_ и продолжением текста не обязательно, но
это же так красиво!
Так можно продлить абсолютно любую аннотацию, все переносы строк и пробелы
заменятся одним пробелом, потому знаки препинания всё же надо ставить.
Можно даже писать текст аннотации на следующей строке после основного тега.
```sql
    -- @query
    -- @ А сообщение про запрос вот тут, пониже
```
Параметры тоже можно расположить в столбик, но обязательно нужны запятые
```sql
    -- @params
    -- @ foo,
    -- @ bar,
    -- @ parameterNumberOne
```

## SQL скрипты

Аннотации в SQL файлах в целом необязательны. Если в SQL файле находится ровно один SQL
скрипт, то `SqlFileStep` просто выполнит этот скрипт и всё.
НО если в SQL файле находится больше одного запроса, каждый из них должен отделяться от
следующего хотя бы одной аннотацией.
```sql
    --- НАЧАЛО ФАЙЛА .sql ---
    INSERT INTO ...
    -- @query
    INSERT INTO ...
    ------ КОНЕЦ ФАЙЛА ------
```
Знак `;` при этом не обязателен, но чтобы файл оставался
валидным SQL файлом всё же его лучше оставлять
Некоторые аннотации, например _&#64;log_ без плейсхолдеров или _&#64;process_,
не требуют SQL запроса, а обрабатываются на месте.
Другие же, такие, как _&#64;log-affected_, _&#64;params_ или _&#64;log_ с плейсхолдерами,
запоминаются и применяются к первому следующему за ними SQL-запросу. При этом аннотации
не обязательно быть непосредственно перед запросом:
```sql
    -- @params param1, param_31
    -- пустые строки, комментарии
    SELECT :param1::int, :param_31::text;
```
Но всё же нежелательно размещать что-то между связанными с запросом
аннотациями и самим запросом.
Также можно применять несколько аннотаций к запросу:
```sql
    -- @query        Я аннотация независимая, пишу это до запроса
    -- @log-affected А я уже буду делать своё дело после
    -- @              запроса. Он, кстати, удалил {0} строк
    -- @params       a1, b2, veryGoodParam
    DELETE ...
```

### Комментарии

Препроцессор полностью игнорирует строки с однострочными комментариями,
которые не являются аннотацией. При этом пропускаются даже те строки, которые посреди
SQL запроса, без ущерба самому запросу.
```sql
    SELECT a,
      b,
    -- А препроцессор меня вообще не видит
      c
    FROM abc_table;
```
Также препроцессор смело пропускает пустые строки или строки в которых только
пробелы/табуляции (возможно это помешает делать строки с помощью $$, но таковы жертвы
простоте препроцессора).
Многострочные комментарии __это плохо__.
Препроцессор не игнорирует их и может посчитать такой комментарий
частью SQL запроса или даже отдельным (!) SQL запросом.
```sql
    -- @log Где-то внизу запрос
    /* А я комментарий, но препроцессор подумает что я запрос
       и потом меня попытаются запустить и всё поломается!
       Лучше не используй меня. Меня даже нормально
       в док-блок не смогли вставить,
       потому я закроюсь вот так ----> * /
    -- @query А вот и запрос!
    -- А я правильный комментарий! Всё круто!
    INSERT INTO ...
```

## Рекомендации и пожелания

Ниже пару рекомендаций к тому, как лучше всего структурировать SQL файлы для
запуска с помощью этого инструмента.
#### 1. Используй временные таблицы.
Если надо что-то куда-то сначала сохранить, а потом из этого выбрать
несколько раз, по полученной выборке выполнить INSERT, а потом ещё
и UPDATE и DELETE'нуть в конце записи, которые
не участвовали в этом круговороте данных, то лучше не писать всё в одном запросе.
Не надо использовать WITH для этого. Он хоть и экономит время, для данной категории SQL
запросов эта экономия мизерна, SQL процессы всё равно не запускаются в рантайме.
Используй временные таблицы. Вот хороший пример:
```sql
    -- @query
    CREATE TEMP TABLE data_to_update_and_insert
    AS SELECT ...
    ;
    -- @query
    INSERT INTO ...
    SELECT * FROM data_to_update_and_insert WHERE ...
    ;
    -- @query
    UPDATE ...
    FROM data_to_update_and_insert
    WHERE ...
    ;
    -- @query
    DROP TABLE data_to_update_and_insert
    ;
```
#### 2. Пиши комментарии
Не стоит и говорить, что сокращения и название таблиц непонятными
именами в сложных запросах - __зло__.
Но не стоит также и забывать о комментариях.
Улучшим хороший пример:
```sql
    -- Создание временной таблицы с данными из
    -- нескольких очень важных источников.
    -- Данные берутся по условию ...
    -- бла бла бла, много понятной информации
    -- @query
    CREATE TEMP TABLE data_to_update_and_insert
    AS SELECT ... ;
    -- Вставка в таблицу данных из времянки выше, таких,
    -- для которых не выполняется условие ...
    -- @query
    INSERT INTO ...
    SELECT * FROM data_to_update_and_insert WHERE ... ;
    -- Обновление записей в таблице ...
    -- данными из времянки выше,
    -- Интересная подробность, про которую
    -- вы возможно не знали - ...
    -- @query
    UPDATE ...
    FROM data_to_update_and_insert
    WHERE ... ;
```
#### 3. Аннотируй
Не стоит делать пустые файлы с одними только _&#64;query_. Подбирай нужную аннотацию,
пиши наиболее важную информацию, ведь это всё отразится в логах,
а значит можно будет быстро проверить,
какой именно запрос занял полчаса, и на каком из них всё сломалось.
Пример становится почти идеальным:
```sql
    -- Создание временной таблицы с данными из
    -- нескольких очень важных источников.
    -- Данные берутся по условию ...
    -- бла бла бла, много понятной информации
    -- @query Создаётся времянка такая-то такая-то
    CREATE TEMP TABLE data_to_update_and_insert
    AS SELECT ... ;
    -- Вставка в таблицу данных из времянки выше, таких,
    -- для которых не выполняется условие ...
    -- @query Выполняется инсерт в таблицу ...
    -- @log-affected
    INSERT INTO ...
    SELECT * FROM data_to_update_and_insert WHERE ... ;
    -- Обновление записей в таблице ...
    -- данными из времянки выше,
    -- Интересная подробность, про которую
    -- вы возможно не знали - ...
    -- @query Обновляются записи в таблице ...
    -- @log-affected [НАЙДИ-МЕНЯ-В-ЛОГАХ] Обновилось {0} записей
    UPDATE ...
    FROM data_to_update_and_insert
    WHERE ... ;
```
#### Если ты используешь Git...
Не пиши всё в одну строку! Пожалуйста!
Даже `;` лучше перенеси на следующую,
чтобы добавление нового условия в `WHERE` или нового поля в `ORDER BY` в конце запроса
помечалось только позитивным зелёненьким `+`.
Вот так:
```sql
   WHERE ...
     AND ...
   ;
```
#### И напоследок
Больше всего времени я, автор этого всего, потратил на написание инструкции, конечно же,
но придумывание и написание такого вот маленького интерпретатора тоже
заняло пару минут.
Всё это сделано для того, чтобы те, кто им пользуется, писали красивые, легко читаемые
и быстро отлаживаемые SQL файлы. Мне будет очень приятно знать, что даже такой примитивный
инструмент помог сделать чей-то проект, а желательно тот проект, для которого это всё
задумывалось, красивее и удобнее в поддержке.
